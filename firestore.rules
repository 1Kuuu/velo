rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return request.auth.uid == userId;
    }
    
    function hasValidPostFields() {
      let required = ['content', 'userId', 'authorId', 'createdAt', 'likesCount', 'commentsCount'];
      let optional = ['mediaUrl', 'mediaType', 'route', 'distance', 'duration', 'authorName', 'authorAvatar', 'authorEmail'];
      let data = request.resource.data;
      
      return data.keys().hasAll(required)
        && data.keys().hasOnly(required.concat(optional))
        && data.likesCount == 0
        && data.commentsCount == 0
        && data.content.size() <= 1000  // 1000 char limit
        && (data.mediaUrl == '' || data.mediaUrl.matches('https://.*'))
        && data.userId == request.auth.uid;
    }
    
    function hasValidCommentFields() {
      let required = ['text', 'userId', 'userName', 'timestamp'];
      let data = request.resource.data;
      
      return data.keys().hasAll(required)
        && data.text.size() <= 500  // 500 char limit
        && data.userId == request.auth.uid;
    }

    // ðŸ”’ Secure user data: Allow all authenticated users to read user documents
    match /users/{userId} {
      allow read: if request.auth != null;
      allow update: if request.auth != null && (
        request.auth.uid == userId ||
        // Allow updates to followers/following arrays and status
        request.resource.data.diff(resource.data).affectedKeys()
          .hasOnly(['followers', 'following', 'status'])
      );
      allow delete: if request.auth != null && request.auth.uid == userId;
      allow create: if request.auth != null && request.auth.uid == userId;
    }

    // ðŸ”’ Secure user profiles
    match /user_profile/{userId} {
      allow read: if isAuthenticated();
      allow update, delete: if isAuthenticated() && isOwner(userId);
      allow create: if isAuthenticated() && isOwner(userId);
      
      // Added rule for followers/following
      allow write: if isAuthenticated() && (
        isOwner(userId) || 
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['followers', 'following', 'status'])
      );

      // Viewed posts subcollection
      match /viewed_posts/{postId} {
        allow read: if isAuthenticated() && isOwner(userId);
        allow write: if isAuthenticated() && isOwner(userId);
      }
    }

    // ðŸ”’ Secure user preferences
    match /user_preferences/{userId} {
      allow read, update, delete: if isAuthenticated() && isOwner(userId);
      allow create: if isAuthenticated() && isOwner(userId);
    }

    // ðŸ”’ Secure posts collection
    match /posts/{postId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && hasValidPostFields();
      allow update: if isAuthenticated() && (
        isOwner(resource.data.userId) || 
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['likesCount', 'commentsCount'])
      );
      allow delete: if isAuthenticated() && isOwner(resource.data.userId);
      
      // Likes subcollection
      match /likes/{userId} {
        allow read: if isAuthenticated();
        allow write: if isAuthenticated() && isOwner(userId);
      }
      
      // Comments subcollection
      match /comments/{commentId} {
        allow read: if isAuthenticated();
        allow create: if isAuthenticated() && hasValidCommentFields();
        allow delete: if isAuthenticated() && (
          isOwner(resource.data.userId) || 
          isOwner(get(/databases/$(database)/documents/posts/$(postId)).data.userId)
        );
      }
    }

    // âœ… Allow authenticated users to access and create chats
    match /chats/{chatId} {
      allow read: if isAuthenticated() && (
        resource.data.participants.hasAny([request.auth.uid])
      );
      allow create: if isAuthenticated();
      allow update: if isAuthenticated() && (
        resource.data.participants.hasAny([request.auth.uid])
      );
      
      match /messages/{messageId} {
        allow read: if isAuthenticated() && (
          get(/databases/$(database)/documents/chats/$(chatId)).data.participants.hasAny([request.auth.uid])
        );
        allow create: if isAuthenticated() && (
          get(/databases/$(database)/documents/chats/$(chatId)).data.participants.hasAny([request.auth.uid])
        );
        allow update: if isAuthenticated() && (
          resource.data.senderId == request.auth.uid &&
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status'])
        );
      }
    }

    // ðŸ”’ Secure events collection
    match /events/{eventId} {
      // Helper function to verify event fields
      function hasValidEventFields() {
        let requiredFields = ['title', 'description', 'date', 'startTime', 'endTime', 'isAllDay', 'repeatStatus', 'color', 'userId'];
        return request.resource.data.keys().hasAll(requiredFields);
      }

      // Allow authenticated users to read all events
      allow read: if request.auth != null;
      
      // Allow authenticated users to create events with required fields
      allow create: if request.auth != null && 
                   hasValidEventFields() &&
                   request.resource.data.userId == request.auth.uid;
      
      // Allow users to update and delete only their own events
      allow update: if request.auth != null && 
                   resource.data.userId == request.auth.uid &&
                   hasValidEventFields() &&
                   request.resource.data.userId == request.auth.uid;
                   
      allow delete: if request.auth != null && 
                   resource.data.userId == request.auth.uid;
    }
  }
}