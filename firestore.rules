rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ðŸ”’ Secure user data: Allow all authenticated users to read user documents
    match /users/{userId} {
      allow read: if request.auth != null;
      allow update: if request.auth != null && (
        request.auth.uid == userId ||
        // Allow updates to followers/following arrays and status
        request.resource.data.diff(resource.data).affectedKeys()
          .hasOnly(['followers', 'following', 'status'])
      );
      allow delete: if request.auth != null && request.auth.uid == userId;
      allow create: if request.auth != null && request.auth.uid == userId;
    }

    // ðŸ”’ Secure user profiles
    match /user_profile/{userId} {
      allow read: if request.auth != null;
      allow update, delete: if request.auth != null && request.auth.uid == userId;
      allow create: if request.auth != null && request.auth.uid == userId;
      
      // Added rule for followers/following
      allow write: if request.auth != null && (
        request.auth.uid == userId || 
        request.resource.data.diff(resource.data).affectedKeys()
          .hasOnly(['followers', 'following', 'status'])
      );
    }

    // ðŸ”’ Secure user preferences
    match /user_preferences/{userId} {
      allow read, update, delete: if request.auth != null && request.auth.uid == userId;
      allow create: if request.auth != null && request.auth.uid == userId;
    }

    // ðŸ”’ Secure posts collection
    match /posts/{postId} {
      // Helper function to verify likesCount update
      function isValidLikeUpdate() {
        let diff = request.resource.data.diff(resource.data);
        return diff.affectedKeys().hasOnly(['likesCount']) &&
              (diff.changedKeys().hasOnly(['likesCount']));
      }
      allow read: if request.auth != null;
      allow create: if request.auth != null &&
                    request.resource.data.keys().hasAll(["content", "userId", "timestamp", "likesCount", "commentsCount"]) &&
                    request.resource.data.keys().hasOnly([
                      "content", "userId", "timestamp", "likesCount", "commentsCount", "imageUrl", "route", "distance", "duration",
                      "authorName", "authorAvatar", "authorEmail"
                    ]) &&
                    request.resource.data.userId == request.auth.uid;
      
      // Allow updates for likes
      allow update: if request.auth != null && 
                    (resource.data.userId == request.auth.uid || isValidLikeUpdate());
      allow delete: if request.auth != null && resource.data.userId == request.auth.uid;
      
      // Added rule for posts
      allow write: if request.auth != null && 
                   request.auth.uid == request.resource.data.userId;
      
      // ðŸ”’ Secure likes inside posts (users can like/unlike)
      match /likes/{userId} {
        // Allow any authenticated user to read if they are trying to see the likes of the post
        allow read: if request.auth != null;
        
        // Ensure user can only create a like if authenticated and not already liked the post
        allow create: if request.auth != null && userId == request.auth.uid;
        
        // Allow users to remove their own like (delete)
        allow delete: if request.auth != null && userId == request.auth.uid;
      }

      // ðŸ”’ Secure comments inside posts (users can comment)
      match /comments/{commentId} {
        // Allow any authenticated user to read comments
        allow read: if request.auth != null;
        
        // Allow authenticated users to create comments
        allow create: if request.auth != null;
        
        // Allow users to delete their own comments
        allow delete: if request.auth != null && 
                      resource.data.userId == request.auth.uid;
      }
    }

    // âœ… Allow authenticated users to access and create chats
    match /chats/{chatId} {
      allow read, write: if request.auth != null; // âœ… Ensures chats exist and are accessible
      
      match /messages/{messageId} {
        allow read, write: if request.auth != null;
        
        // Allow status updates
        allow update: if request.auth != null && 
          (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status']));
      }
    }

    // ðŸ”’ Secure events collection
    match /events/{eventId} {
      // Helper function to verify event fields
      function hasValidEventFields() {
        let requiredFields = ['title', 'description', 'date', 'startTime', 'endTime', 'isAllDay', 'repeatStatus', 'color', 'userId'];
        return request.resource.data.keys().hasAll(requiredFields);
      }

      // Allow authenticated users to read all events
      allow read: if request.auth != null;
      
      // Allow authenticated users to create events with required fields
      allow create: if request.auth != null && 
                   hasValidEventFields() &&
                   request.resource.data.userId == request.auth.uid;
      
      // Allow users to update and delete only their own events
      allow update: if request.auth != null && 
                   resource.data.userId == request.auth.uid &&
                   hasValidEventFields() &&
                   request.resource.data.userId == request.auth.uid;
                   
      allow delete: if request.auth != null && 
                   resource.data.userId == request.auth.uid;
    }
  }
}